Hey Jason, 

I thought your implementation of cannibals and missionaries looked great, and you made a few code decisions that were creative and made your algorithms run very smoothly. One example of this is in your getSuccessors() function. I like how you only loop through the number of missionaries only and deduce the number of cannibals in the state. I don't see how you're testing scenarios with the same number of missionaries and different numbers of cannibals, but your report shows your testing thoroughly, so I trust that your code was finding all solutions. I was also wondering where you were checking if the number of cannibals on the boat was more than the number of misisonaries on the boat. I couldn't find this check in your code, but again, I may have missed something. I assume that in your extension, if there are more cannibals in the boat than missionaries, the missionaries would be eaten, and I would like to have seen some kind of discussion about this in your report. 

Your BFS function and discussion looked right on the money - don't have any comments for this section other than that it's excellent. I also believe your code for the depth first searches are right on point, but I would have like to see a litte more discussion about them in your write up. These recursions are pretty complex, so even a short discussion how the path is backchained in your code would be helpful. I did the Lossy missionaries and cannibals extension and your explanation for that was very good. Originally I wanted to keep E as a part of the state (which I should've realized we don't want to include constants in the state...) and realized as I was coding that the last part of the state should actually be the number of missionaries eaten, so I was pleasantly surprised you already thought about that without implementing it! One comment I would like to propose to your explanation is that you say you can eat up to e < E missionaries. I believe this should be e <= E since you can eat up to E missionaries. This is a very minor point, and think your discussion was very comprehensive and accurate. 

Overall I would rate your technical soundness a 4 because I couldn't figure out how you're checking that each boat ride does not contain more cannibals than misisonaries. I would rate your technical depth a 5 because you implemented some creative techniques in getSuccessor() and I really like your successor legality test function. I would give your presentation quality a 4 because I think the discussion for your df searches is a little lacking, but not wrong. 

Great job Jason! 

Hey Evan, 

I thought your implementation of the missionaries and cannibals problem looked good. You thoroughly introduced the problem in your discussion, and made your intentions clear at the beginning of the discussion. I would have liked to see more of a discussion for the rest of your code, however. Your getSuccessors() function looks like it works well. I think you used more variables than you needed to which made it kind of hard to follow - I would have liked to see some interaction between the state, as in drawing variables form the state rather than calculating them, but that is simply a stylistic choice that I think you utillize better later in your code. One thing that I was curious about was that you check to see if a state is legal at the beginning of getSuccessors() and returns no successors if it's an illegal state. I think this is a bit redundant, because instead, you can just check if a node is legal or not before adding it to the successors list. By doing this, you only have to run getSuccessors() on legal states, and all the successors you return will also be legal. Your way definitely works, but I don't think you should have to run getSuccessors() on illegal states, which will save lots of run time and space when your code is extended to more missionaries and more cannibals. 

Your BFS and DFS all look very good and I really like your coding style, where you changed the UUSearchNode to be just called Node, and I think your Results custom class is a really great idea. However, I would have liked to see more interaction with your code samples in your discussions. I want to see why your code works and arguments why you're finding the fastest path in BFS, or why you're finding all successors for a current node. I would have also liked to see more of a discussion for the lossy extension. I believe your updated state is correct, and your number of states is correct, but I want to see what exactly you would change in your getSuccessors() function. You mention what kinds of states you would accept, but I want to see how you would find these extra states. This is because the lossy extension makes this problem much more complex, so I think it's impportant to really dive into what you would do to your code to extend it to this problem. 

Overall I think your technical soundness is 4 because I think you could have made your getSuccessors() function more efficient (i.e. by not accepting illegal states and only running getSuccessors() on legal states). I think your technical depth is a 5 given your code accuaracy and creativeness with your classes - your Node class and Results class. I would give your discussion a 3/4 though because I would have liked to see you dive deeper into the extension and really interact with your code in your code discussions. Overall great job Evan!
